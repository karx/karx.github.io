<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" href="/assets/css/style.css?v=98b01076f4eee0a60ca6e354decb56c9c8e08869" media="screen" type="text/css">
    <link rel="stylesheet" href="/assets/css/print.css" media="print" type="text/css">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>jsprim: utilities for primitive JavaScript types | karx.github.io</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="jsprim: utilities for primitive JavaScript types" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Open channel for karx compute system interactions" />
<meta property="og:description" content="Open channel for karx compute system interactions" />
<link rel="canonical" href="http://localhost:4000/FlutterArsenal/fromgithub/node_modules/jsprim/" />
<meta property="og:url" content="http://localhost:4000/FlutterArsenal/fromgithub/node_modules/jsprim/" />
<meta property="og:site_name" content="karx.github.io" />
<script type="application/ld+json">
{"description":"Open channel for karx compute system interactions","@type":"WebPage","headline":"jsprim: utilities for primitive JavaScript types","url":"http://localhost:4000/FlutterArsenal/fromgithub/node_modules/jsprim/","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>
    <header>
      <div class="inner">
        <a href="http://localhost:4000/">
          <h1>karx.github.io</h1>
        </a>
        <h2>Open channel for karx compute system interactions</h2>
        
          <a href="https://github.com/karx/karx.github.io" class="button"><small>View project on</small> GitHub</a>
        
        
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1 id="jsprim-utilities-for-primitive-javascript-types">jsprim: utilities for primitive JavaScript types</h1>

<p>This module provides miscellaneous facilities for working with strings,
numbers, dates, and objects and arrays of these basic types.</p>

<h3 id="deepcopyobj">deepCopy(obj)</h3>

<p>Creates a deep copy of a primitive type, object, or array of primitive types.</p>

<h3 id="deepequalobj1-obj2">deepEqual(obj1, obj2)</h3>

<p>Returns whether two objects are equal.</p>

<h3 id="isemptyobj">isEmpty(obj)</h3>

<p>Returns true if the given object has no properties and false otherwise.  This
is O(1) (unlike <code class="highlighter-rouge">Object.keys(obj).length === 0</code>, which is O(N)).</p>

<h3 id="haskeyobj-key">hasKey(obj, key)</h3>

<p>Returns true if the given object has an enumerable, non-inherited property
called <code class="highlighter-rouge">key</code>.  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">For information on enumerability and ownership of properties, see
the MDN
documentation.</a></p>

<h3 id="foreachkeyobj-callback">forEachKey(obj, callback)</h3>

<p>Like Array.forEach, but iterates enumerable, owned properties of an object
rather than elements of an array.  Equivalent to:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                callback(key, obj[key]);
        }
}
</code></pre></div></div>

<h3 id="flattenobjectobj-depth">flattenObject(obj, depth)</h3>

<p>Flattens an object up to a given level of nesting, returning an array of arrays
of length “depth + 1”, where the first “depth” elements correspond to flattened
columns and the last element contains the remaining object .  For example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flattenObject({
    'I': {
        'A': {
            'i': {
                'datum1': [ 1, 2 ],
                'datum2': [ 3, 4 ]
            },
            'ii': {
                'datum1': [ 3, 4 ]
            }
        },
        'B': {
            'i': {
                'datum1': [ 5, 6 ]
            },
            'ii': {
                'datum1': [ 7, 8 ],
                'datum2': [ 3, 4 ],
            },
            'iii': {
            }
        }
    },
    'II': {
        'A': {
            'i': {
                'datum1': [ 1, 2 ],
                'datum2': [ 3, 4 ]
            }
        }
    }
}, 3)
</code></pre></div></div>

<p>becomes:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[
    [ 'I',  'A', 'i',   { 'datum1': [ 1, 2 ], 'datum2': [ 3, 4 ] } ],
    [ 'I',  'A', 'ii',  { 'datum1': [ 3, 4 ] } ],
    [ 'I',  'B', 'i',   { 'datum1': [ 5, 6 ] } ],
    [ 'I',  'B', 'ii',  { 'datum1': [ 7, 8 ], 'datum2': [ 3, 4 ] } ],
    [ 'I',  'B', 'iii', {} ],
    [ 'II', 'A', 'i',   { 'datum1': [ 1, 2 ], 'datum2': [ 3, 4 ] } ]
]
</code></pre></div></div>

<p>This function is strict: “depth” must be a non-negative integer and “obj” must
be a non-null object with at least “depth” levels of nesting under all keys.</p>

<h3 id="flatteniterobj-depth-func">flattenIter(obj, depth, func)</h3>

<p>This is similar to <code class="highlighter-rouge">flattenObject</code> except that instead of returning an array,
this function invokes <code class="highlighter-rouge">func(entry)</code> for each <code class="highlighter-rouge">entry</code> in the array that
<code class="highlighter-rouge">flattenObject</code> would return.  <code class="highlighter-rouge">flattenIter(obj, depth, func)</code> is logically
equivalent to <code class="highlighter-rouge">flattenObject(obj, depth).forEach(func)</code>.  Importantly, this
version never constructs the full array.  Its memory usage is O(depth) rather
than O(n) (where <code class="highlighter-rouge">n</code> is the number of flattened elements).</p>

<p>There’s another difference between <code class="highlighter-rouge">flattenObject</code> and <code class="highlighter-rouge">flattenIter</code> that’s
related to the special case where <code class="highlighter-rouge">depth === 0</code>.  In this case, <code class="highlighter-rouge">flattenObject</code>
omits the array wrapping <code class="highlighter-rouge">obj</code> (which is regrettable).</p>

<h3 id="pluckobj-key">pluck(obj, key)</h3>

<p>Fetch nested property “key” from object “obj”, traversing objects as needed.
For example, <code class="highlighter-rouge">pluck(obj, "foo.bar.baz")</code> is roughly equivalent to
<code class="highlighter-rouge">obj.foo.bar.baz</code>, except that:</p>

<ol>
  <li>If traversal fails, the resulting value is undefined, and no error is
thrown.  For example, <code class="highlighter-rouge">pluck({}, "foo.bar")</code> is just undefined.</li>
  <li>If “obj” has property “key” directly (without traversing), the
corresponding property is returned.  For example,
<code class="highlighter-rouge">pluck({ 'foo.bar': 1 }, 'foo.bar')</code> is 1, not undefined.  This is also
true recursively, so <code class="highlighter-rouge">pluck({ 'a': { 'foo.bar': 1 } }, 'a.foo.bar')</code> is
also 1, not undefined.</li>
</ol>

<h3 id="randeltarray">randElt(array)</h3>

<p>Returns an element from “array” selected uniformly at random.  If “array” is
empty, throws an Error.</p>

<h3 id="startswithstr-prefix">startsWith(str, prefix)</h3>

<p>Returns true if the given string starts with the given prefix and false
otherwise.</p>

<h3 id="endswithstr-suffix">endsWith(str, suffix)</h3>

<p>Returns true if the given string ends with the given suffix and false
otherwise.</p>

<h3 id="parseintegerstr-options">parseInteger(str, options)</h3>

<p>Parses the contents of <code class="highlighter-rouge">str</code> (a string) as an integer. On success, the integer
value is returned (as a number). On failure, an error is <strong>returned</strong> describing
why parsing failed.</p>

<p>By default, leading and trailing whitespace characters are not allowed, nor are
trailing characters that are not part of the numeric representation. This
behaviour can be toggled by using the options below. The empty string (<code class="highlighter-rouge">''</code>) is
not considered valid input. If the return value cannot be precisely represented
as a number (i.e., is smaller than <code class="highlighter-rouge">Number.MIN_SAFE_INTEGER</code> or larger than
<code class="highlighter-rouge">Number.MAX_SAFE_INTEGER</code>), an error is returned. Additionally, the string
<code class="highlighter-rouge">'-0'</code> will be parsed as the integer <code class="highlighter-rouge">0</code>, instead of as the IEEE floating point
value <code class="highlighter-rouge">-0</code>.</p>

<p>This function accepts both upper and lowercase characters for digits, similar to
<code class="highlighter-rouge">parseInt()</code>, <code class="highlighter-rouge">Number()</code>, and <a href="https://illumos.org/man/3C/strtol">strtol(3C)</a>.</p>

<p>The following may be specified in <code class="highlighter-rouge">options</code>:</p>

<table>
  <thead>
    <tr>
      <th>Option</th>
      <th>Type</th>
      <th>Default</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>base</td>
      <td>number</td>
      <td>10</td>
      <td>numeric base (radix) to use, in the range 2 to 36</td>
    </tr>
    <tr>
      <td>allowSign</td>
      <td>boolean</td>
      <td>true</td>
      <td>whether to interpret any leading <code class="highlighter-rouge">+</code> (positive) and <code class="highlighter-rouge">-</code> (negative) characters</td>
    </tr>
    <tr>
      <td>allowImprecise</td>
      <td>boolean</td>
      <td>false</td>
      <td>whether to accept values that may have lost precision (past <code class="highlighter-rouge">MAX_SAFE_INTEGER</code> or below <code class="highlighter-rouge">MIN_SAFE_INTEGER</code>)</td>
    </tr>
    <tr>
      <td>allowPrefix</td>
      <td>boolean</td>
      <td>false</td>
      <td>whether to interpret the prefixes <code class="highlighter-rouge">0b</code> (base 2), <code class="highlighter-rouge">0o</code> (base 8), <code class="highlighter-rouge">0t</code> (base 10), or <code class="highlighter-rouge">0x</code> (base 16)</td>
    </tr>
    <tr>
      <td>allowTrailing</td>
      <td>boolean</td>
      <td>false</td>
      <td>whether to ignore trailing characters</td>
    </tr>
    <tr>
      <td>trimWhitespace</td>
      <td>boolean</td>
      <td>false</td>
      <td>whether to trim any leading or trailing whitespace/line terminators</td>
    </tr>
    <tr>
      <td>leadingZeroIsOctal</td>
      <td>boolean</td>
      <td>false</td>
      <td>whether a leading zero indicates octal</td>
    </tr>
  </tbody>
</table>

<p>Note that if <code class="highlighter-rouge">base</code> is unspecified, and <code class="highlighter-rouge">allowPrefix</code> or <code class="highlighter-rouge">leadingZeroIsOctal</code>
are, then the leading characters can change the default base from 10. If <code class="highlighter-rouge">base</code>
is explicitly specified and <code class="highlighter-rouge">allowPrefix</code> is true, then the prefix will only be
accepted if it matches the specified base. <code class="highlighter-rouge">base</code> and <code class="highlighter-rouge">leadingZeroIsOctal</code>
cannot be used together.</p>

<p><strong>Context:</strong> It’s tricky to parse integers with JavaScript’s built-in facilities
for several reasons:</p>

<ul>
  <li><code class="highlighter-rouge">parseInt()</code> and <code class="highlighter-rouge">Number()</code> by default allow the base to be specified in the
input string by a prefix (e.g., <code class="highlighter-rouge">0x</code> for hex).</li>
  <li><code class="highlighter-rouge">parseInt()</code> allows trailing nonnumeric characters.</li>
  <li><code class="highlighter-rouge">Number(str)</code> returns 0 when <code class="highlighter-rouge">str</code> is the empty string (<code class="highlighter-rouge">''</code>).</li>
  <li>Both functions return incorrect values when the input string represents a
valid integer outside the range of integers that can be represented precisely.
Specifically, <code class="highlighter-rouge">parseInt('9007199254740993')</code> returns 9007199254740992.</li>
  <li>Both functions always accept <code class="highlighter-rouge">-</code> and <code class="highlighter-rouge">+</code> signs before the digit.</li>
  <li>Some older JavaScript engines always interpret a leading 0 as indicating
octal, which can be surprising when parsing input from users who expect a
leading zero to be insignificant.</li>
</ul>

<p>While each of these may be desirable in some contexts, there are also times when
none of them are wanted. <code class="highlighter-rouge">parseInteger()</code> grants greater control over what
input’s permissible.</p>

<h3 id="iso8601date">iso8601(date)</h3>

<p>Converts a Date object to an ISO8601 date string of the form
“YYYY-MM-DDTHH:MM:SS.sssZ”.  This format is not customizable.</p>

<h3 id="parsedatetimestr">parseDateTime(str)</h3>

<p>Parses a date expressed as a string, as either a number of milliseconds since
the epoch or any string format that Date accepts, giving preference to the
former where these two sets overlap (e.g., strings containing small numbers).</p>

<h3 id="hrtimedifftimea-timeb">hrtimeDiff(timeA, timeB)</h3>

<p>Given two hrtime readings (as from Node’s <code class="highlighter-rouge">process.hrtime()</code>), where timeA is
later than timeB, compute the difference and return that as an hrtime.  It is
illegal to invoke this for a pair of times where timeB is newer than timeA.</p>

<h3 id="hrtimeaddtimea-timeb">hrtimeAdd(timeA, timeB)</h3>

<p>Add two hrtime intervals (as from Node’s <code class="highlighter-rouge">process.hrtime()</code>), returning a new
hrtime interval array.  This function does not modify either input argument.</p>

<h3 id="hrtimeaccumtimea-timeb">hrtimeAccum(timeA, timeB)</h3>

<p>Add two hrtime intervals (as from Node’s <code class="highlighter-rouge">process.hrtime()</code>), storing the
result in <code class="highlighter-rouge">timeA</code>.  This function overwrites (and returns) the first argument
passed in.</p>

<h3 id="hrtimenanosectimea-hrtimemicrosectimea-hrtimemillisectimea">hrtimeNanosec(timeA), hrtimeMicrosec(timeA), hrtimeMillisec(timeA)</h3>

<p>This suite of functions converts a hrtime interval (as from Node’s
<code class="highlighter-rouge">process.hrtime()</code>) into a scalar number of nanoseconds, microseconds or
milliseconds.  Results are truncated, as with <code class="highlighter-rouge">Math.floor()</code>.</p>

<h3 id="validatejsonobjectschema-object">validateJsonObject(schema, object)</h3>

<p>Uses JSON validation (via JSV) to validate the given object against the given
schema.  On success, returns null.  On failure, <em>returns</em> (does not throw) a
useful Error object.</p>

<h3 id="extrapropertiesobject-allowed">extraProperties(object, allowed)</h3>

<p>Check an object for unexpected properties.  Accepts the object to check, and an
array of allowed property name strings.  If extra properties are detected, an
array of extra property names is returned.  If no properties other than those
in the allowed list are present on the object, the returned array will be of
zero length.</p>

<h3 id="mergeobjectsprovided-overrides-defaults">mergeObjects(provided, overrides, defaults)</h3>

<p>Merge properties from objects “provided”, “overrides”, and “defaults”.  The
intended use case is for functions that accept named arguments in an “args”
object, but want to provide some default values and override other values.  In
that case, “provided” is what the caller specified, “overrides” are what the
function wants to override, and “defaults” contains default values.</p>

<p>The function starts with the values in “defaults”, overrides them with the
values in “provided”, and then overrides those with the values in “overrides”.
For convenience, any of these objects may be falsey, in which case they will be
ignored.  The input objects are never modified, but properties in the returned
object are not deep-copied.</p>

<p>For example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mergeObjects(undefined, { 'objectMode': true }, { 'highWaterMark': 0 })
</code></pre></div></div>

<p>returns:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ 'objectMode': true, 'highWaterMark': 0 }
</code></pre></div></div>

<p>For another example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mergeObjects(
    { 'highWaterMark': 16, 'objectMode': 7 }, /* from caller */
    { 'objectMode': true },                   /* overrides */
    { 'highWaterMark': 0 });                  /* default */
</code></pre></div></div>

<p>returns:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ 'objectMode': true, 'highWaterMark': 16 }
</code></pre></div></div>

<h1 id="contributing">Contributing</h1>

<p>See separate <a href="/FlutterArsenal/fromgithub/node_modules/jsprim/CONTRIBUTING.md">contribution guidelines</a>.</p>

        </section>

        <aside id="sidebar">
          

          
            <p class="repo-owner"><a href="https://github.com/karx/karx.github.io">karx.github.io</a> is maintained by <a href="https://github.com/karx">karx</a>.</p>
          

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</p>
        </aside>
      </div>
    </div>

    
  </body>
</html>
